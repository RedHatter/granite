*** garglk/event.c	2012-11-14 21:18:54.148512653 -0800
--- ../event.c	2012-11-14 21:15:47.544512654 -0800
***************
*** 27,32 ****
--- 27,34 ----
  #include "glk.h"
  #include "garglk.h"
  
+ #define countof(x) (sizeof x / sizeof *x)
+ 
  /* A pointer to the place where the pending glk_select() will store its
     event. When not inside a glk_select() call, this will be NULL. */
  event_t *gli_curevent = NULL;
***************
*** 168,183 ****
  /* Handle a keystroke. */
  void gli_input_handle_key(glui32 key)
  {
      if (gli_more_focus)
      {
          gli_input_more_focus();
      }
- 
      else
      {
          switch (key)
          {
              case keycode_Tab:
                  gli_input_next_focus();
                  return;
              case keycode_PageUp:
--- 170,233 ----
  /* Handle a keystroke. */
  void gli_input_handle_key(glui32 key)
  {
+     window_t *win = gli_focuswin;
+     
      if (gli_more_focus)
      {
          gli_input_more_focus();
      }
      else
      {
          switch (key)
          {
              case keycode_Tab:
+                 {
+                    window_textbuffer_t *dwin = win->data;
+                    int i, n, z;
+ 
+                    //Step backward to find last space on input line
+                    for (i=dwin->numchars; i>0; i--)
+                    {
+                    	if (dwin->chars[i] == 0x20)
+                    	    break;
+                    }
+                    	
+                    //Step forward to extract last word
+                    glui32 word[dwin->numchars-i];
+ 
+                    for (n=i; n<dwin->numchars; n++)
+                    	word[n-i] = dwin->chars[n];
+ 
+                     //Loop through lines of prv output
+                     for (i=1; i<=dwin->scrollmax; i++)
+                     {
+                         //Step backwards through char of the line
+                         for (n=dwin->lines[i].len; n>0; n--)
+                        	{
+                             //Step forward again, break if char doesn't match word
+                        	    for (z=0; z<countof(word); z++)
+                        	    {
+                                 //Convert to lowercase
+                        		    char c = dwin->lines[i].chars[n+z];
+                        		    if (c >= 'A' && c <= 'Z')
+                        		        c = c+32;
+ 
+                        		    if (c != (char)word[z])
+                        		        break;
+                        		        
+                        		    if (z == countof(word)-1)
+                        		        goto End; //Match found, break all three loops
+                        		}
+                        	}
+                     }
+                     End:
+                     
+                     /* Call input event for each char in tab complete
+                      i is the line, n is the first char of match, z is length of match,
+                      so n+z is end of match and start of tab complete */
+                     for (n++; (char)dwin->lines[i].chars[n+z] != 0x20; n++)
+ 			            gcmd_buffer_accept_readline(win, dwin->lines[i].chars[n+z]);
+                 }
                  gli_input_next_focus();
                  return;
              case keycode_PageUp:
***************
*** 191,199 ****
                  break;
          }
      }
- 
-     window_t *win = gli_focuswin;
- 
      if (!win)
          return;
  
--- 241,246 ----
